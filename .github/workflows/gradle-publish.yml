pipeline {
    agent any

    tools {
        gradle 'Gradle_8' // Aseg√∫rate de que el nombre coincida con tu configuraci√≥n global de Jenkins
        jdk 'JDK_17'      // Aseg√∫rate de que el nombre coincida con tu configuraci√≥n global de Jenkins
    }

    environment {
        // Variables de entorno para tu pipeline
        DOCKER_REGISTRY = 'docker.io' // O 'ghcr.io' para GitHub Container Registry, o tu registro privado
        DOCKER_USERNAME = 'tu_usuario_docker' // Tu usuario de Docker Hub o GHCR
        IMAGE_NAME = 'juanmafraile/proyectokubernetes' // Reemplaza con el nombre de tu imagen en el registro
        
        // Utiliza el SHA del commit para el tag de la imagen, o si prefieres, env.BUILD_NUMBER
        IMAGE_TAG = "${env.GIT_COMMIT ? env.GIT_COMMIT[0..7] : 'latest'}" 
        
        K8S_NAMESPACE = 'default' // O el namespace de Kubernetes donde desplegar√°s tu aplicaci√≥n
        // Reemplaza 'kubernetes-credentials' con el ID de tu credencial de Kubernetes en Jenkins
        KUBERNETES_CREDENTIAL_ID = 'kubernetes-kubeconfig-id' // ID de tu credencial Kubeconfig (tipo Secret File)
        // O si usas un ServiceAccount Token: 'kubernetes-serviceaccount-token-id' (tipo Secret Text)
        
        // Variables para ArgoCD
        ARGOCD_SERVER = 'argocd-server.argocd.svc.cluster.local'
        ARGOCD_APP_NAME = 'proyecto-kubernetes-app'
    }

    stages {
        stage('Clone') {
            steps {
                git url: 'https://github.com/JuanMaFraile/ProyectoKubernetes.git', branch: 'main'
            }
        }

        stage('Build with Gradle') {
            steps {
                sh 'chmod +x gradlew' // Aseg√∫rate de que el script Gradle Wrapper sea ejecutable
                sh './gradlew clean build'
            }
        }

        stage('Run Tests') {
            steps {
                sh 'chmod +x gradlew'
                sh './gradlew test'
            }
            post {
                always {
                    // Publica los resultados de los tests
                    junit '**/build/test-results/**/*.xml'
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    // Aseg√∫rate de que el Dockerfile est√© en la ra√≠z de tu proyecto
                    // Y que el JAR generado por Gradle (ej. build/libs/your-app.jar) sea copiado correctamente en el Dockerfile
                    docker.build("${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}", "-f Dockerfile .")
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    // 'docker-registry-credentials' es el ID de la credencial de tipo 'Username with password'
                    // que configuraste en Jenkins para tu registro Docker (ej. Docker Hub)
                    withCredentials([usernamePassword(credentialsId: 'docker-registry-credentials', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        docker.withRegistry("https://${DOCKER_REGISTRY}", DOCKER_USERNAME) {
                            docker.image("${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}").push()
                        }
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    // Esta etapa requiere que 'kubectl' est√© disponible en el agente de Jenkins
                    // y que tenga acceso a tu cl√∫ster de Kubernetes.

                    // Opci√≥n 1: Usando un Kubeconfig (recomendado para agentes que no son pods en K8s)
                    // La credencial 'kubernetes-kubeconfig-id' debe ser de tipo 'Secret file' en Jenkins
                    withCredentials([file(credentialsId: KUBERNETES_CREDENTIAL_ID, variable: 'KUBECONFIG_FILE')]) {
                        // Exporta KUBECONFIG para que kubectl use el archivo de credenciales
                        sh "export KUBECONFIG=${KUBECONFIG_FILE}"
                        sh "kubectl config use-context $(kubectl config current-context)" // Asegura el contexto correcto
                        
                        // Aplica los manifiestos de Kubernetes (aseg√∫rate de que est√©n en la ruta correcta, ej. kubernetes/)
                        sh "kubectl apply -f kubernetes/deployment.yaml -n ${K8S_NAMESPACE}"
                        sh "kubectl apply -f kubernetes/service.yaml -n ${K8S_NAMESPACE}"
                        // Si tienes otros manifiestos (Ingress, ConfigMaps, etc.), agr√©galos aqu√≠.

                        // ¬°MUY IMPORTANTE! Actualiza la imagen del Deployment para que Kubernetes tire de la nueva imagen
                        // Aseg√∫rate de que el nombre del deployment en deployment.yaml sea '${IMAGE_NAME}'
                        // y que el nombre del contenedor dentro de ese deployment tambi√©n sea '${IMAGE_NAME}'
                        sh "kubectl set image deployment/${IMAGE_NAME} ${IMAGE_NAME}=${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} -n ${K8S_NAMESPACE}"
                        
                        // Si usas Helm:
                        // sh "helm upgrade --install ${IMAGE_NAME} ./helm_chart_path --set image.repository=${DOCKER_REGISTRY}/${IMAGE_NAME},image.tag=${IMAGE_TAG} -n ${K8S_NAMESPACE}"
                    }

                    // Opci√≥n 2: Usando un token de ServiceAccount (si el agente es un pod de K8s o tienes acceso directo al token)
                    // La credencial 'kubernetes-serviceaccount-token-id' debe ser de tipo 'Secret text' en Jenkins
                    // withCredentials([string(credentialsId: KUBERNETES_CREDENTIAL_ID, variable: 'K8S_TOKEN')]) {
                    //     sh "kubectl config set-cluster my-cluster --server='https://YOUR_KUBERNETES_API_SERVER'"
                    //     sh "kubectl config set-context my-context --cluster=my-cluster --user='my-user'"
                    //     sh "kubectl config set-credentials my-user --token=${K8S_TOKEN}"
                    //     sh "kubectl config use-context my-context"
                    //     sh "kubectl apply -f kubernetes/deployment.yaml -n ${K8S_NAMESPACE}"
                    //     sh "kubectl set image deployment/${IMAGE_NAME} ${IMAGE_NAME}=${DOCKER_REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG} -n ${K8S_NAMESPACE}"
                    // }
                }
            }
        }

        stage('Trigger ArgoCD Sync') {
            steps {
                script {
                    echo "üöÄ Triggering ArgoCD sync for application: ${ARGOCD_APP_NAME}"
                    
                    // Trigger ArgoCD sync via kubectl
                    withCredentials([file(credentialsId: KUBERNETES_CREDENTIAL_ID, variable: 'KUBECONFIG_FILE')]) {
                        sh """
                            export KUBECONFIG=${KUBECONFIG_FILE}
                            
                            # Trigger sync for development environment
                            kubectl patch application ${ARGOCD_APP_NAME} -n argocd --type='merge' -p='{"spec":{"syncPolicy":{"automated":{"prune":true,"selfHeal":true}}}}'
                            
                            # Force sync
                            kubectl patch application ${ARGOCD_APP_NAME} -n argocd --type='merge' -p='{"metadata":{"annotations":{"argocd.argoproj.io/trigger":"manual"}}}'
                            
                            echo "‚úÖ ArgoCD sync triggered successfully"
                        """
                    }
                }
            }
        }

        stage('Verify ArgoCD Sync') {
            steps {
                script {
                    echo "üîç Verifying ArgoCD sync status..."
                    
                    withCredentials([file(credentialsId: KUBERNETES_CREDENTIAL_ID, variable: 'KUBECONFIG_FILE')]) {
                        sh """
                            export KUBECONFIG=${KUBECONFIG_FILE}
                            
                            # Wait for sync to complete
                            kubectl wait --for=condition=Synced application/${ARGOCD_APP_NAME} -n argocd --timeout=300s
                            
                            # Get sync status
                            kubectl get application ${ARGOCD_APP_NAME} -n argocd -o jsonpath='{.status.sync.status}'
                            
                            echo "‚úÖ ArgoCD sync verification completed"
                        """
                    }
                }
            }
        }
    }

    post {
        always {
            cleanWs() // Limpia el espacio de trabajo del agente despu√©s de cada build
            echo 'Pipeline finalizado.'
        }
        success {
            echo '¬°Despliegue completado correctamente!'
            echo 'üöÄ ArgoCD ha reconocido la acci√≥n de CD y sincronizado la aplicaci√≥n'
        }
        failure {
            echo '¬°El pipeline fall√≥! Revisa los logs.'
        }
    }
}
